{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst bcrypt = require('bcrypt');\n\nconst cookie = require('cookie');\n\nconst jsonwebtoken = require('jsonwebtoken');\n\nclass Auth {\n  constructor() {\n    if (!Auth.instance) {\n      Auth.instance = this;\n    }\n\n    return Auth.instance;\n  }\n\n  init(options) {\n    if (this.isInitialized) return;\n    this.pathUri = options.pathUri;\n    this.redirectUri = options.redirectUri;\n    this.postLogoutRedirectUri = options.postLogoutRedirectUri;\n    this.cookieSecret = options.cookieSecret;\n    this.cookieLifeTime = options.cookieLifeTime;\n    this.tokenLifetime = options.tokenLifetime;\n    this.isInitialized = true;\n    return this;\n  }\n\n  async handleRegister(req, res, userRegisterFields, database, options) {\n    const fields = {};\n    userRegisterFields.forEach(field => fields[field] = req.body[field]);\n\n    try {\n      fields.password = await bcrypt.hash(fields.password, 10);\n      const existingUser = await database.findOne(_objectSpread(_objectSpread({}, options), {}, {\n        field: {\n          field: 'email',\n          value: fields.email\n        }\n      }));\n\n      if (existingUser) {\n        throw new Error('User with same email already exists');\n      }\n\n      const newUser = await database.createOne(_objectSpread(_objectSpread({}, options), {}, {\n        fields\n      }));\n      return res.json(newUser);\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async handleLogin(req, res, database, options) {\n    const {\n      email,\n      password\n    } = req.body;\n\n    try {\n      const existingUser = await database.findOne(_objectSpread(_objectSpread({}, options), {}, {\n        field: {\n          field: 'email',\n          value: email\n        }\n      }));\n\n      if (!existingUser) {\n        throw new Error('Bad email or password');\n      }\n\n      const compared = await bcrypt.compare(password, existingUser.password);\n\n      if (!compared) {\n        throw new Error('Bad email or password');\n      }\n\n      const token = jsonwebtoken.sign({\n        userId: existingUser.id\n      }, this.cookieSecret, {\n        expiresIn: this.tokenLifetime\n      });\n      existingUser.tokens = [...existingUser.tokens, token];\n      await existingUser.save();\n      res.setHeader('Set-Cookie', cookie.serialize('auth', token, {\n        httpOnly: true,\n        secure: false,\n        sameSite: 'strict',\n        maxAge: this.cookieLifeTime,\n        path: this.pathUri\n      }));\n      res.json({\n        token\n      });\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  authRequired(handler) {\n    return async (req, res) => {\n      try {\n        const verifyed = jsonwebtoken.verify(req.cookies.auth, this.cookieSecret);\n        req.userId = verifyed.userId;\n        return handler(req, res);\n      } catch (e) {\n        res.status(401).json({\n          error: e.message\n        });\n      }\n    };\n  }\n\n  async handleLogout(req, res, database, options) {\n    try {\n      const authToken = req.cookies.auth;\n      const verifyed = jsonwebtoken.verify(authToken, this.cookieSecret);\n      const user = await database.findById(_objectSpread(_objectSpread({}, options), {}, {\n        id: verifyed.userId\n      }));\n      user.tokens = user.tokens.filter(token => token !== authToken);\n      res.setHeader('Set-Cookie', cookie.serialize('auth', '', {\n        httpOnly: true,\n        secure: false,\n        sameSite: 'strict',\n        maxAge: this.cookieLifeTime,\n        path: this.pathUri\n      }));\n      res.writeHead(302, {\n        Location: this.postLogoutRedirectUri\n      });\n      res.end(); // res.json({ hello: 'hello' })\n    } catch (e) {\n      res.status(500).json({\n        error: e\n      });\n    }\n  }\n\n  async getSession(req) {\n    try {\n      const authToken = cookie.parse(req.headers.cookie).auth;\n\n      if (!authToken) {\n        throw new Error('no auth token');\n      }\n\n      const verifyed = jsonwebtoken.verify(authToken, this.cookieSecret);\n      return verifyed;\n    } catch (e) {}\n  }\n\n}\n\nconst auth = new Auth();\nmodule.exports = auth;","map":{"version":3,"sources":["/Users/misha/Desktop/miauth/core/Auth/Auth.js"],"names":["bcrypt","require","cookie","jsonwebtoken","Auth","constructor","instance","init","options","isInitialized","pathUri","redirectUri","postLogoutRedirectUri","cookieSecret","cookieLifeTime","tokenLifetime","handleRegister","req","res","userRegisterFields","database","fields","forEach","field","body","password","hash","existingUser","findOne","value","email","Error","newUser","createOne","json","e","handleLogin","compared","compare","token","sign","userId","id","expiresIn","tokens","save","setHeader","serialize","httpOnly","secure","sameSite","maxAge","path","authRequired","handler","verifyed","verify","cookies","auth","status","error","message","handleLogout","authToken","user","findById","filter","writeHead","Location","end","getSession","parse","headers","module","exports"],"mappings":"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","sourcesContent":["const bcrypt = require('bcrypt')\nconst cookie = require('cookie')\nconst jsonwebtoken = require('jsonwebtoken')\n\nclass Auth {\n  constructor() {\n    if (!Auth.instance) {\n      Auth.instance = this\n    }\n    return Auth.instance\n  }\n\n  init(options) {\n    if (this.isInitialized) return\n\n    this.pathUri = options.pathUri\n    this.redirectUri = options.redirectUri\n    this.postLogoutRedirectUri = options.postLogoutRedirectUri\n    this.cookieSecret = options.cookieSecret\n    this.cookieLifeTime = options.cookieLifeTime\n    this.tokenLifetime = options.tokenLifetime\n\n    this.isInitialized = true\n    return this\n  }\n\n  async handleRegister(req, res, userRegisterFields, database, options) {\n    const fields = {}\n    userRegisterFields.forEach(field => (fields[field] = req.body[field]))\n    try {\n      fields.password = await bcrypt.hash(fields.password, 10)\n      const existingUser = await database.findOne({\n        ...options,\n        field: { field: 'email', value: fields.email },\n      })\n      if (existingUser) {\n        throw new Error('User with same email already exists')\n      }\n\n      const newUser = await database.createOne({ ...options, fields })\n\n      return res.json(newUser)\n    } catch (e) {\n      throw e\n    }\n  }\n\n  async handleLogin(req, res, database, options) {\n    const { email, password } = req.body\n    try {\n      const existingUser = await database.findOne({\n        ...options,\n        field: { field: 'email', value: email },\n      })\n      if (!existingUser) {\n        throw new Error('Bad email or password')\n      }\n      const compared = await bcrypt.compare(password, existingUser.password)\n      if (!compared) {\n        throw new Error('Bad email or password')\n      }\n      const token = jsonwebtoken.sign(\n        { userId: existingUser.id },\n        this.cookieSecret,\n        { expiresIn: this.tokenLifetime }\n      )\n      existingUser.tokens = [...existingUser.tokens, token]\n      await existingUser.save()\n\n      res.setHeader(\n        'Set-Cookie',\n        cookie.serialize('auth', token, {\n          httpOnly: true,\n          secure: process.env.NODE_ENV !== 'development',\n          sameSite: 'strict',\n          maxAge: this.cookieLifeTime,\n          path: this.pathUri,\n        })\n      )\n      res.json({ token })\n    } catch (e) {\n      throw e\n    }\n  }\n\n  authRequired(handler) {\n    return async (req, res) => {\n      try {\n        const verifyed = jsonwebtoken.verify(\n          req.cookies.auth,\n          this.cookieSecret\n        )\n        req.userId = verifyed.userId\n        return handler(req, res)\n      } catch (e) {\n        res.status(401).json({ error: e.message })\n      }\n    }\n  }\n\n  async handleLogout(req, res, database, options) {\n    try {\n      const authToken = req.cookies.auth\n      const verifyed = jsonwebtoken.verify(authToken, this.cookieSecret)\n      const user = await database.findById({ ...options, id: verifyed.userId })\n      user.tokens = user.tokens.filter(token => token !== authToken)\n      res.setHeader(\n        'Set-Cookie',\n        cookie.serialize('auth', '', {\n          httpOnly: true,\n          secure: process.env.NODE_ENV !== 'development',\n          sameSite: 'strict',\n          maxAge: this.cookieLifeTime,\n          path: this.pathUri,\n        })\n      )\n\n      res.writeHead(302, {\n        Location: this.postLogoutRedirectUri,\n      })\n      res.end()\n      // res.json({ hello: 'hello' })\n    } catch (e) {\n      res.status(500).json({ error: e })\n    }\n  }\n  async getSession(req){\n    try {\n     const authToken = cookie.parse(req.headers.cookie).auth\n     if(!authToken){\n       throw new Error('no auth token')\n     }\n     const verifyed = jsonwebtoken.verify(authToken, this.cookieSecret) \n     return verifyed\n    } catch (e) {\n      \n    }\n  }\n}\n\nconst auth = new Auth()\nmodule.exports = auth\n"]},"metadata":{},"sourceType":"script"}