{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst bcrypt = require('bcrypt');\n\nconst cookie = require('cookie');\n\nconst jsonwebtoken = require('jsonwebtoken');\n\nclass Auth {\n  constructor() {\n    if (!Auth.instance) {\n      Auth.instance = this;\n    }\n\n    return Auth.instance;\n  }\n\n  init(options) {\n    if (this.isInitialized) return;\n    this.pathUri = options.pathUri;\n    this.redirectUri = options.redirectUri;\n    this.postLogoutRedirectUri = options.postLogoutRedirectUri;\n    this.cookieSecret = options.cookieSecret;\n    this.cookieLifeTime = options.cookieLifeTime;\n    this.tokenLifetime = options.tokenLifetime;\n    this.isInitialized = true;\n    return this;\n  }\n\n  async handleRegister(req, res, userRegisterFields, database, options) {\n    const fields = {};\n    userRegisterFields.forEach(field => fields[field] = req.body[field]);\n\n    try {\n      fields.password = await bcrypt.hash(fields.password, 10);\n\n      if (await database.findOne(_objectSpread(_objectSpread({}, options), {}, {\n        field: {\n          email: fields.email\n        }\n      }))) {\n        throw new Error('User with same email already exists');\n      }\n\n      const newUser = await database.createOne(_objectSpread(_objectSpread({}, options), {}, {\n        fields\n      }));\n      return res.json(newUser);\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async handleLogin(req, res, database, options) {\n    const {\n      email,\n      password\n    } = req.body;\n\n    try {\n      const existingUser = await database.findOne(_objectSpread(_objectSpread({}, options), {}, {\n        field: {\n          email\n        }\n      }));\n\n      if (!existingUser) {\n        throw new Error('Bad email or password');\n      }\n\n      const compared = await bcrypt.compare(password, existingUser.password);\n\n      if (!compared) {\n        throw new Error('Bad email or password');\n      }\n\n      const token = jsonwebtoken.sign({\n        userId: existingUser.id\n      }, this.cookieSecret, {\n        expiresIn: this.tokenLifetime\n      });\n      existingUser.tokens = [...existingUser.tokens, token];\n      await existingUser.save();\n      res.setHeader('Set-Cookie', cookie.serialize('auth', token, {\n        httpOnly: true,\n        secure: false,\n        sameSite: 'strict',\n        maxAge: this.cookieLifeTime,\n        path: this.pathUri\n      }));\n      res.json({\n        token\n      });\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async authRequired(handler) {\n    return (req, res) => {\n      try {\n        const verifyed = jsonwebtoken.verify(req.cookies.auth, this.cookieSecret);\n        req.userId = verifyed.userId;\n        return handler(req, res);\n      } catch (e) {\n        return res.status(500).json({\n          error: e.message\n        });\n      }\n    };\n  }\n\n  async handleLogout(req, res, database, options) {\n    try {\n      const authToken = req.cookies.auth;\n      const verifyed = jsonwebtoken.verify(authToken, this.cookieSecret);\n      const user = await database.findById(_objectSpread(_objectSpread({}, options), {}, {\n        id: verifyed.userId\n      }));\n      user.tokens = user.tokens.filter(token => token !== authToken);\n      res.setHeader('Set-Cookie', cookie.serialize('auth', '', {\n        httpOnly: true,\n        secure: false,\n        sameSite: 'strict',\n        maxAge: this.cookieLifeTime,\n        path: this.pathUri\n      }));\n      res.writeHead(302, {\n        Location: this.postLogoutRedirectUri\n      });\n      res.end(); // res.json({ hello: 'hello' })\n    } catch (e) {\n      res.status(500).json({\n        error: e\n      });\n    }\n  }\n\n}\n\nconst auth = new Auth();\nmodule.exports = auth;","map":{"version":3,"sources":["/Users/misha/Desktop/miauth/core/Auth/Auth.js"],"names":["bcrypt","require","cookie","jsonwebtoken","Auth","constructor","instance","init","options","isInitialized","pathUri","redirectUri","postLogoutRedirectUri","cookieSecret","cookieLifeTime","tokenLifetime","handleRegister","req","res","userRegisterFields","database","fields","forEach","field","body","password","hash","findOne","email","Error","newUser","createOne","json","e","handleLogin","existingUser","compared","compare","token","sign","userId","id","expiresIn","tokens","save","setHeader","serialize","httpOnly","secure","sameSite","maxAge","path","authRequired","handler","verifyed","verify","cookies","auth","status","error","message","handleLogout","authToken","user","findById","filter","writeHead","Location","end","module","exports"],"mappings":"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","sourcesContent":["const bcrypt = require('bcrypt')\nconst cookie = require('cookie')\nconst jsonwebtoken = require('jsonwebtoken')\n\nclass Auth {\n  constructor() {\n    if (!Auth.instance) {\n      Auth.instance = this\n    }\n    return Auth.instance\n  }\n\n  init(options) {\n    if (this.isInitialized) return\n\n    this.pathUri = options.pathUri\n    this.redirectUri = options.redirectUri\n    this.postLogoutRedirectUri = options.postLogoutRedirectUri\n    this.cookieSecret = options.cookieSecret\n    this.cookieLifeTime = options.cookieLifeTime\n    this.tokenLifetime = options.tokenLifetime\n\n    this.isInitialized = true\n    return this\n  }\n\n  async handleRegister(req, res, userRegisterFields, database, options) {\n    const fields = {}\n    userRegisterFields.forEach(field => (fields[field] = req.body[field]))\n    try {\n      fields.password = await bcrypt.hash(fields.password, 10)\n\n      if (\n        await database.findOne({ ...options, field: { email: fields.email } })\n      ) {\n        throw new Error('User with same email already exists')\n      }\n\n      const newUser = await database.createOne({ ...options, fields })\n\n      return res.json(newUser)\n    } catch (e) {\n      throw e\n    }\n  }\n\n  async handleLogin(req, res, database, options) {\n    const { email, password } = req.body\n    try {\n      const existingUser = await database.findOne({\n        ...options,\n        field: { email },\n      })\n      if (!existingUser) {\n        throw new Error('Bad email or password')\n      }\n      const compared = await bcrypt.compare(password, existingUser.password)\n      if (!compared) {\n        throw new Error('Bad email or password')\n      }\n      const token = jsonwebtoken.sign(\n        { userId: existingUser.id },\n        this.cookieSecret,\n        { expiresIn: this.tokenLifetime }\n      )\n      existingUser.tokens = [...existingUser.tokens, token]\n      await existingUser.save()\n\n      res.setHeader(\n        'Set-Cookie',\n        cookie.serialize('auth', token, {\n          httpOnly: true,\n          secure: process.env.NODE_ENV !== 'development',\n          sameSite: 'strict',\n          maxAge: this.cookieLifeTime,\n          path: this.pathUri,\n        })\n      )\n      res.json({ token })\n    } catch (e) {\n      throw e\n    }\n  }\n\n  async authRequired(handler) {\n    return (req, res) => {\n      try {\n        const verifyed = jsonwebtoken.verify(\n          req.cookies.auth,\n          this.cookieSecret\n        )\n        req.userId = verifyed.userId\n        return handler(req, res)\n      } catch (e) {\n        return res.status(500).json({ error: e.message })\n      }\n    }\n  }\n\n  async handleLogout(req, res, database, options) {\n    try {\n      const authToken = req.cookies.auth\n      const verifyed = jsonwebtoken.verify(authToken, this.cookieSecret)\n      const user = await database.findById({ ...options, id: verifyed.userId })\n      user.tokens = user.tokens.filter(token => token !== authToken)\n      res.setHeader(\n        'Set-Cookie',\n        cookie.serialize('auth', '', {\n          httpOnly: true,\n          secure: process.env.NODE_ENV !== 'development',\n          sameSite: 'strict',\n          maxAge: this.cookieLifeTime,\n          path: this.pathUri,\n        })\n      )\n\n      res.writeHead(302, {\n        Location: this.postLogoutRedirectUri,\n      })\n      res.end()\n      // res.json({ hello: 'hello' })\n    } catch (e) {\n      res.status(500).json({ error: e })\n    }\n  }\n}\n\nconst auth = new Auth()\nmodule.exports = auth\n"]},"metadata":{},"sourceType":"script"}